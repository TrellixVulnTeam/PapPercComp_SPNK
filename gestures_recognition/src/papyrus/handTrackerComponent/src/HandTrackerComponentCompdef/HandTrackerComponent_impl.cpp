// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define HandTrackerComponentCompdef_HandTrackerComponent_impl_BODY

/************************************************************
 HandTrackerComponent_impl class body
 ************************************************************/

// include associated header file
//#include "../../src/HandTrackerComponentCompdef/HandTrackerComponent_impl.h"

#include <cstdio>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <iostream>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

// Derived includes directives
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"
#include "geometry_msgs/msg/pose.hpp"
#include "geometry_msgs/msg/pose_array.hpp"

using namespace std;
using namespace std::chrono_literals;

class handTrackerWrapper : public rclcpp::Node
{
  public:
    handTrackerWrapper() : Node("handtracker_wrapper"), count_(0)
    {
		publisher_ = this->create_publisher<geometry_msgs::msg::PoseArray>("hand_joints", 10);
		timer_ = this->create_wall_timer(500ms, std::bind(&handTrackerWrapper::timer_callback, this));

		// prepare socket for communication
			// create socket
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
		{
		std::cout << "Failed to open stream socket";
		return;
		}
		std::cout << "Success opening stream socket";

		// Configure socket
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = INADDR_ANY;
		server.sin_port = 50000;  // most likely unused in all OS
		if (bind(sock, (struct sockaddr *)&server, sizeof(server)))
		{
		std::cout << "Error binding to socket..";
		return;
		}

		std::cout << " with port " << server.sin_port << std::endl;
    }

  private:

    void timer_callback()
    {
        listen(sock, 5);

	msgsock = accept(sock, 0, 0);
        if (msgsock == -1) {
            perror("accept");
            return;
        } else
        do {
            memset(buf, 0, sizeof(buf));
            if ((rval  = read(msgsock, buf,  2048)) < 0)
                perror("reading stream message");
            else if (rval == 0) {}
            else
		received = buf;
        } while (rval > 0);
        close(msgsock);

	build_float_message();
    }

    void build_float_message()
    {
	std::vector<float> vec;
	auto pointVector = geometry_msgs::msg::PoseArray();

	std::size_t index = 0;
	std::size_t found = received.find(",", index);

	do
	{
		std::string pointString = received.substr(index, found - index);
		vec.emplace_back( atof( pointString.c_str() ) );
		if(vec.size() == 3)
		{
			auto p = geometry_msgs::msg::Pose();
			p.position.x = vec[0];
			p.position.y = vec[1];
			p.position.z = 0;
			//p.position.z = vec[2];
			//p.orientation.z = vec[2];

			pointVector.poses.push_back(p);

			vec.clear();
		}

		index = found;
		index++;

		found = received.find(",", index);

	} while(found != std::string::npos);

//      std::cout << "size of final pointvector: " << pointVector.pointvector.size() << std::endl;
//      std::cout << "received: " << received << std::endl;

	pointVector.header.frame_id = std::string("/base_link");
	publisher_->publish(pointVector);
    }

    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Publisher<geometry_msgs::msg::PoseArray>::SharedPtr publisher_;
    size_t count_;

    //socket for TCP
    int sock;
    struct sockaddr_in server;
    int msgsock;
    int rval;
    char buf[2048];
    std::string received;

};


int main(int argc, char ** argv)
{
  (void) argc;
  (void) argv;

  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<handTrackerWrapper>());
  rclcpp::shutdown();
  return 0;
}
/************************************************************
 End of HandTrackerComponent_impl class body
 ************************************************************/
