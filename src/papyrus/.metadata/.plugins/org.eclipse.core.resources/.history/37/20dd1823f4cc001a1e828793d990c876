// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define GestureDetectorComponentCompdef_GestureDetectorComponent_impl_BODY

/************************************************************
 GestureDetectorComponent_impl class body
 ************************************************************/

// include associated header file
//#include "../../src/GestureDetectorComponentCompdef/GestureDetectorComponent_impl.h"

// Derived includes directives
#include <cstdio>
#include "math.h"
#include <memory>
#include <iostream>
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"
#include "geometry_msgs/msg/pose.hpp"
#include "geometry_msgs/msg/pose_array.hpp"

// socket libraries for communication with our ROS node
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

using std::placeholders::_1;

#define palm 			 0
#define	thumb_base 		 1
#define	thumb_middle_base 	 2
#define	thumb_middle_tip 	 3
#define	thumb_tip 		 4
#define	index_base 		 5
#define	index_middle_base 	 6
#define	index_middle_tip 	 7
#define	index_tip 		 8
#define	mid_base 		 9
#define	mid_middle_base 	 10
#define	mid_middle_tip 	 11
#define	mid_tip 		 12
#define	ring_base 		 13
#define	ring_middle_base 	 14
#define	ring_middle_tip 	 15
#define	ring_tip 		 16
#define	little_base 		 17
#define	little_middle_base 	18
#define	little_middle_tip  	19
#define	little_tip 		20

class Gestures
{
//	typedef handtracker_interface::msg::Point point;
	typedef geometry_msgs::msg::Pose point;


	public:
		Gestures ( ){}
		~Gestures() {}

		Gestures(const std::vector<point>  &input)
		{
			points21 = input;
			//thumb = (isFingerOpen(points21[thumb_tip], points21[mid_middle_tip], points21[thumb_middle_base]) || isFingerOpen(points21[thumb_tip], points21[ring_middle_base], points21[thumb_middle_base]));
			double width = getDistance(points21[index_middle_base], points21[little_middle_base]);
			thumb = isThumbOpen(points21[thumb_tip], points21[mid_middle_base], 					points21[thumb_middle_base]);
			/* index = isFingerOpen(points21[index_tip], points21[index_base], points21[index_middle_base]);
			middle = isFingerOpen(points21[mid_tip], points21[mid_base], points21[mid_middle_base]);
			ring = isFingerOpen(points21[ring_tip], points21[ring_base], points21[ring_middle_base]);
			little = isFingerOpen(points21[little_tip], points21[little_base], 					points21[little_middle_base]);	*/
			index = isFingerOpen(points21[index_tip], points21[palm], width);
			middle = isFingerOpen(points21[mid_tip], points21[palm], width);
			ring = isFingerOpen(points21[ring_tip], points21[palm], width);
			little = isFingerOpen(points21[little_tip], points21[palm], width);

			std::cout << thumb  << index  << middle  << ring  << little  << std::endl;

		}

		// send information back to mediapipe
		void sendInformation (const std::string& result)
		{
			int sock;
			struct sockaddr_in server;
			struct hostent *hp;
			char buffer[20];
			std::string hostname = "localhost";
			size_t i;

			// Convert string to char array
			//strcpy(buffer, result.c_str());
			for(i = 0; i < result.size(); i++)
			{
				buffer[i] = result[i];
			}
			buffer[i] = '\0';

			//init socket
			sock = socket(AF_INET, SOCK_STREAM, 0);
		
			if(sock < 0)
			{
		  		std::cout << "GestureRecognition: Failed to create socket!" << std::endl;
		  		return;
			}

			server.sin_family = AF_INET;
			hp = gethostbyname(hostname.c_str());
			memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
			server.sin_port = 40000;
 
			//connect to socket to send info
			if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)
			{
				perror("GestureRecognition connect");
			  	//std::cout << "GestureRecognition: Failed to connect to stream socket" << std::endl;
				close(sock);
			  	return;
			}

			//send info
			std::cout << std::endl;
			if (write(sock, buffer, sizeof(buffer)) < 0)
			  	std::cout << "GestureRecognition: Failed to write to stream socket" << std::endl;

			//close socket
			close(sock);
		}

		double getDistance(const point&A, const point& B)
		{
			return sqrt(pow(B.position.x - A.position.x, 2) + pow(B.position.y - A.position.y, 2));
		}

		bool isDistanceBigger(double distanceA, double distanceB)
		{
			bool bigger = false;
			if (distanceA <= distanceB)
				bigger = false;
			else
				bigger = true;
			return bigger;
		}

		void getMaxY(float* maximumY, int* index)
		{
			float max = 0;
			int inx = 0;
			for(size_t i = 0; i < points21.size(); ++i)
				if( max < points21[i].position.y) {
					max = points21[i].position.y;
					inx = i;
				}
			*maximumY = max;
			*index = inx;
			//return  max;
		}

		void getMinY(float* minimumY, int* index)
		{
			float min = 100;
			int inx = 0;
			for(size_t i = 0; i < points21.size(); ++i)
				if( min > points21[i].position.y) {
					min = points21[i].position.y;
					inx = i;
				}

			*minimumY = min;
			*index = inx;
			//return  min, index;
		}

		void getMaxX(float* maximumX, int* index)
		{
			float max = 0;
			int inx = 0;
			for(size_t i = 0; i < points21.size(); ++i)
				if( max < points21[i].position.x) {
					max = points21[i].position.x;
					inx = i;
				}
			*maximumX = max;
			*index = inx;
			//return  max;
		}

		void getMinX(float* minimumX, int* index)
		{
			float min = 100;
			int inx = 0;
			for(size_t i = 0; i < points21.size(); ++i)
				if( min > points21[i].position.x) {
					min = points21[i].position.x;
					inx = i;
				}

			*minimumX = min;
			*index = inx;
			//return  min;
		}

		//bool isFingerOpen(const point& tip, const point& base, const point& middle_base)
		bool isFingerOpen(const point& tip, const point& palm_point, double width)
		{
			double distanceFirst = getDistance(tip, palm_point);
			//double distanceSecond = getDistance(tip, middle_base);
			//double distanceToPalm = getDistance(points21[8], points21[1]);

			bool finger = (isDistanceBigger(distanceFirst, width));
			return finger;

		}

		bool isThumbOpen(const point& tip, const point& base, const point& middle_base)

		{
			double distanceFirst = getDistance(tip, base);
			double distanceSecond = getDistance(tip, middle_base);
			//double distanceToPalm = getDistance(points21[8], points21[1]);

			bool finger = (isDistanceBigger(distanceFirst, distanceSecond));
			return finger;

		}


		bool isGesturePeace()
		{
			bool result = false;
			if (!thumb && index && middle && !ring && !little)
				result = true;
			return result;
		}

		bool isGestureOkGo()
		{
			bool result = false;
			if (thumb && !index && !middle && !ring && !little)
				result = true;
			return result;
		}

		bool isGestureStop()
		{
			bool result = false;
			if (thumb && index && middle && ring && little)
				result = true;
			return result;
		}

		bool isGestureScroll()
		{
			bool result = false;
			if (thumb && index && !middle && !ring && !little)
				result = true;
			return result;
		}

		bool isGesturePhone()
		{
			bool result = false;
			if (thumb && !index && !middle && !ring && little)
				result = true;
			return result;
		}

		bool isGestureRock()
		{
			bool result = false;
			if (!thumb && index && !middle && !ring && little)
				result = true;
			return result;
		}

		bool isGestureAttention()
		{
			bool result = false;
			if (!thumb && index && !middle && !ring && !little)
				result = true;
			return result;
		}

		bool isGestureHand()
		{
			bool result = true;
			//TODO: Do the actual implementation of the hand gesture
			//std::cout << "printing x value of index finger tip: " << points21[index_tip].x << " , " << getDistance(points21[thumb_base], points21[4]) << std::endl;

			return result;
		}


		bool isGestureRight()
		{
			bool result = false;
			//implementation of the point right gesture
			float minX;
			int min_idx;
			getMinX(&minX, &min_idx);
			if (min_idx == 8)
				result = true;
			return result;
		}


		bool isGestureLeft()
		{
			bool result = false;
			//implementation of the point left gesture
			float maxX;
			int max_idx;
			getMaxX(&maxX, &max_idx);
			if (max_idx == 8)
				result = true;
			return result;
		}

	private:
		std::vector<point> points21;
		bool thumb;
		bool index;
		bool middle;
		bool ring;
		bool little;

};


class GestureRecognition : public rclcpp::Node
{
	public:
		GestureRecognition() : Node("Gesture_Recognition")
		{
			subscriber_ = this->create_subscription<geometry_msgs::msg::PoseArray>("hand_joints", 10, std::bind(&GestureRecognition::topic_callback, this, _1));
		}

	private:
		void topic_callback(const geometry_msgs::msg::PoseArray::SharedPtr msg) const
		{
			Gestures gestures((msg->poses));
			std::string result = "";

			if(gestures.isGesturePeace())
			{
				std::cout << "Gesture: Peace" << std::endl;
				result = "Peace";
			}
			else if(gestures.isGestureOkGo())
			{
				std::cout << "Gesture: Ok, go" << std::endl;
				result = "Ok, go";
			}
			else if(gestures.isGestureStop())
			{
				std::cout << "Gesture: Stop" << std::endl;
				result = "Stop";
			}
			else if(gestures.isGestureScroll())
			{
				std::cout << "Gesture: Scroll" << std::endl;
				result = "Scroll";
			}
			else if(gestures.isGesturePhone())
			{
				std::cout << "Gesture: Phone" << std::endl;
				result = "Phone";
			}
			else if(gestures.isGestureRock())
			{
				std::cout << "Gesture: Rock" << std::endl;
				result = "Rock";
			}
			else if(gestures.isGestureAttention()) {
				if (gestures.isGestureRight())
				{
					std::cout << "Gesture: Go right" << std::endl;
					result = "Go right";
				}
				else if(gestures.isGestureLeft())
				{
					std::cout << "Gesture: Go left" << std::endl;
					result = "Go left";
				}
				else
				{
					std::cout << "Gesture: Attention" << std::endl;
					result = "Attention";
				}
			}
			else
			{
				std::cout << "Gesture: Unknown" << std::endl;
				result = "unknown";
			}
			//else if(gestures.isGestureHand())
				//std::cout << "Hand gesture recognized" << std::endl;
			//else
				//std::cout << "No gesture recognized" << std::endl;

			// send information back to mediapipe
			gestures.sendInformation(result);

		}

		rclcpp::Subscription<geometry_msgs::msg::PoseArray>::SharedPtr subscriber_;

};

int main(int argc, char ** argv)
{

  printf("hello world gesture recognition subscriber package\n");

  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<GestureRecognition>());
  rclcpp::shutdown();

  return 0;
}

/************************************************************
 End of GestureDetectorComponent_impl class body
 ************************************************************/
