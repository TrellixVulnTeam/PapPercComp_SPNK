// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Fruit_detectionCompdef_FruitDetection_impl_BODY

/************************************************************
 FruitDetection_impl class body
 ************************************************************/

// include associated header file
#include "Fruit_detectionCompdef/FruitDetection_impl.h"

// Derived includes directives
#include "rclcpp/rclcpp.hpp"

static auto img_msg = sensor_msgs::msg::Image();

namespace Fruit_detectionCompdef {

// static attributes (if any)

/**
 * 
 * @param options 
 */
FruitDetection_impl::FruitDetection_impl(rclcpp::NodeOptions /*in*/options) :
		FruitDetection(options) {
			this->detectionClient = this->create_client<fruit_detection::srv::Detection>("DetectionService");
			this->diseaseClient = this->create_client<fruit_detection::srv::Classification>("DiseaseService");
}

/**
 * 
 * @param image 
 */
void FruitDetection_impl::FruitDetectionHandler(
		const sensor_msgs::msg::Image::SharedPtr /*in*/image) {
			img_msg = *image;
			//cv::Mat cvImage(img_msg.height, img_msg.width, CV_8UC3, img_msg.data.data());
			cv_bridge::CvImagePtr cv_ptr = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
			const cv::Mat imageCopy = cv_ptr->image;
				
			if(!imageCopy.empty() && this->test) {
				RCLCPP_INFO(this->get_logger(), "Non empty image received");
				char c = (char)cv::waitKey(10);
				if( c == 27 || c == 'q' || c == 'Q' ) {
					rclcpp::shutdown();
				}
				RCLCPP_INFO(this->get_logger(), "Starting Object Detection");
				this->detectFruits(cv_ptr);
				this->test=false;
				// std::vector<std::string> diseases;
				// RCLCPP_INFO(this->get_logger(), "Detection Completed");

				//RCLCPP_INFO(this->get_logger(), "Starting Disease Classification");
				// for(auto const & box : boxes){
				// 	cv::Mat singleFruitImage = imageCopy(cv::Rect(std::get<1>(box),std::get<2>(box),std::get<3>(box),std::get<4>(box)));
				// 	diseases.push_back(this->classifyDisease(singleFruitImage));
				// }
				// RCLCPP_INFO(this->get_logger(), "Classification Complete");
				// for(std::vector<int>::size_type i = 0; i != boxes.size(); i++) {
				//    drawBox(imageCopy, boxes[i], diseases[i]);
				// }
				//TODO publish correct data
				// std_msgs::msg::String msg;
				// msg.data = diseases[0];
				// Disease_pub_->publish(msg);
			}


}

/**
 * 
 * @param img
 */
void FruitDetection_impl::classifyDisease(cv_bridge::CvImagePtr cv_ptr, std::vector<fruit_detection::msg::ClassBox> boxes){
	while (!this->diseaseClient->wait_for_service(std::chrono::seconds(1))) {
		if (!rclcpp::ok()) {
			RCLCPP_ERROR(this->get_logger(), "Interrupted while waiting for the service. Exiting.");
			return;
		}
		RCLCPP_INFO(this->get_logger(), "service not available, waiting again...");
  	}
	auto request = std::make_shared<fruit_detection::srv::Classification::Request>();
	request->img = *cv_ptr->toImageMsg();
	request->boxes = boxes;
	RCLCPP_INFO(this->get_logger(), "Sending Request");
	this->diseaseClient->async_send_request(request, [this](rclcpp::Client<fruit_detection::srv::Classification>::SharedFuture future){
		std::vector<fruit_detection::msg::ClassBox> boxes= future.get()->new_boxes;
		for(fruit_detection::msg::ClassBox box : boxes){
			RCLCPP_INFO(this->get_logger(), "Class: %s ,Score: %d, Disease: " , box.fruit_class.data(), box.score, box.disease.data());
			RCLCPP_INFO(this->get_logger(), "xmin: %f ,xmax: %f" , box.xmin, box.xmax);
			RCLCPP_INFO(this->get_logger(), "ymin: %f ,ymax: %f" , box.ymin, box.ymax);
		}
		//TODO draw image!
	});
}

/**
 * 
 *@param img 
 */
void FruitDetection_impl::detectFruits(cv_bridge::CvImagePtr cv_ptr){
	while (!this->detectionClient->wait_for_service(std::chrono::seconds(1))) {
		if (!rclcpp::ok()) {
			RCLCPP_ERROR(this->get_logger(), "Interrupted while waiting for the service. Exiting.");
			return;
		}
		RCLCPP_INFO(this->get_logger(), "service not available, waiting again...");
  	}
	auto request = std::make_shared<fruit_detection::srv::Detection::Request>();
	request->img = *cv_ptr->toImageMsg();
	RCLCPP_INFO(this->get_logger(), "Sending detection request");
	this->detectionClient->async_send_request(request, [this, cv_ptr](rclcpp::Client<fruit_detection::srv::Detection>::SharedFuture future){
		RCLCPP_INFO(this->get_logger(), "Received detection results");
		std::vector<fruit_detection::msg::ClassBox> boxes= future.get()->classes;
		RCLCPP_INFO(this->get_logger(), "Start disease classification");
		this->classifyDisease(cv_ptr, boxes);
	});
}


} // of namespace Fruit_detectionCompdef

/************************************************************
 End of FruitDetection_impl class body
 ************************************************************/
