// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Garbage_classificationCompdef_Garbage_classification_impl_BODY

/************************************************************
 Garbage_classification_impl class body
 ************************************************************/

// include associated header file
#include "Garbage_classificationCompdef/Garbage_classification_impl.h"

// Derived includes directives
#include "rclcpp/rclcpp.hpp"

#define GLASS 0
#define PAPER 1
#define CARDBOARD 2
#define PLASTIC 3
#define METAL 4
#define TRASH 5


#define DIM1 384
#define DIM2 512

#define TOPK 5

static std::unordered_map<int, std::string> CLASSES = {
		{GLASS, "GLASS" },
		{ PAPER, "PAPER" },
		{ CARDBOARD, "CARDBOARD" },
		{ PLASTIC, "PLASTIC" },
		{ METAL, "METAL" },
		{ TRASH, "TRASH" }
};

namespace Garbage_classificationCompdef {

// static attributes (if any)

/**
 * 
 * @param options 
 */
Garbage_classification_impl::Garbage_classification_impl(
		rclcpp::NodeOptions /*in*/options) :
		Garbage_classification(options) {
	//TODO make configurable
	classifier_ = torch::jit::load("/home/seedship/TUM/SS20/Model-Driven\ Approach\ for\ Robotics\ Perception/PapPercComp/models/resnet18/transcripted_model_cuda.pt");
	camNum_ = 0;
}

/**
 * 
 * @param image 
 */
void Garbage_classification_impl::classify(
		const sensor_msgs::msg::Image::SharedPtr /*in*/image) {
//	RCLCPP_INFO(this->get_logger(),"Image received!");
	img_msg_ = *image;

	cv::Mat img(img_msg_.height, img_msg_.width, CV_8UC3,img_msg_.data.data());
	cv::Mat img_resized, img_show;
	cv::resize(img, img_resized, cv::Size(DIM1, DIM2));

	torch::Tensor img_tensor = torch::from_blob(img_resized.data, {img_resized.rows, img_resized.cols, 3}, torch::kByte).clone();
	img_tensor = img_tensor.permute({2, 0, 1}); // convert to CxHxW
	img_tensor = img_tensor / 255.0;

	img_tensor = img_tensor.unsqueeze(0).cuda();
	std::vector<torch::jit::IValue> input;
	input.emplace_back(img_tensor);

	torch::Tensor output = classifier_.forward(input).toTensor();
	auto prediction = output.topk(TOPK);
	auto topClasses = std::get<1>(prediction);
	topClasses = topClasses.flatten();

	std::string ans("Top " + std::to_string(TOPK) + ":");
	for (unsigned idx = 0; idx < TOPK; idx++) {
		ans += (" " + CLASSES[topClasses[idx].item().toInt()]);
	}
	classification_.set__data(ans);


	// Does not work on my Arch Linux
	cv::resize(img, img_show, cv::Size(1280, 960));
	cv::putText(img_show, ans, cv::Point2i(10, 40), cv::FONT_HERSHEY_TRIPLEX, 1.4, cv::Scalar(0, 255 ,0));
	cv::imshow("Garbage Classification Image", img_show);
	cv::waitKey(10);

	RCLCPP_INFO(this->get_logger(), ans);
	classification_pub_->publish(classification_);
}

} // of namespace Garbage_classificationCompdef

/************************************************************
 End of Garbage_classification_impl class body
 ************************************************************/
