// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Garbage_classificationCompdef_Garbage_classification_impl_BODY

/************************************************************
 Garbage_classification_impl class body
 ************************************************************/

// include associated header file
#include "Garbage_classificationCompdef/Garbage_classification_impl.h"

// Derived includes directives
#include "rclcpp/rclcpp.hpp"

#define GLASS 0
#define PAPER 1
#define CARDBOARD 2
#define PLASTIC 3
#define METAL 4
#define TRASH 5


#define DIM1 384
#define DIM2 512

#define TOPK 5

const static std::unordered_map<int, std::string> CLASSES = {
		{GLASS, "GLASS" },
		{ PAPER, "PAPER" },
		{ CARDBOARD, "CARDBOARD" },
		{ PLASTIC, "PLASTIC" },
		{ METAL, "METAL" },
		{ TRASH, "TRASH" }
};

namespace Garbage_classificationCompdef {

// static attributes (if any)

/**
 *
 * @param options
 */
Garbage_classification_impl::Garbage_classification_impl(
		rclcpp::NodeOptions /*in*/options) :
		Garbage_classification(options) {
	//TODO make configurable
	classifier_ = torch::jit::load("~/PapPercComp/garbage_classification/models/resnet18/transcripted_model_cuda.pt");
	use_cuda_ = 1;

	for (unsigned x = 0; x < 6; x++) {
		classifications_[x] = 0;
	}
}

/**
 *
 * @param image
 */
void Garbage_classification_impl::classify(
		const sensor_msgs::msg::Image::SharedPtr /*in*/image) {
//	RCLCPP_INFO(this->get_logger(),"Image received!");
	img_msg_ = *image;

	cv::Mat img(img_msg_.height, img_msg_.width, CV_8UC3,img_msg_.data.data());
	cv::Mat img_resized, img_show;
	cv::resize(img, img_resized, cv::Size(DIM1, DIM2));

	torch::Tensor img_tensor = torch::from_blob(img_resized.data, {img_resized.rows, img_resized.cols, 3}, torch::kByte).clone();
	img_tensor = img_tensor.permute({2, 0, 1}); // convert to CxHxW
	img_tensor = img_tensor / 255.0;

	img_tensor = img_tensor.unsqueeze(0);
	if (use_cuda_) {
		img_tensor = img_tensor.cuda();
	}
	std::vector<torch::jit::IValue> input;
	input.emplace_back(img_tensor);

	torch::Tensor output = classifier_.forward(input).toTensor();
	auto prediction = output.topk(TOPK);
	auto topClasses = std::get<1>(prediction);
	topClasses = topClasses.flatten();

	std::string ans("Top " + std::to_string(TOPK) + ":");
	for (unsigned idx = 0; idx < TOPK; idx++) {
		ans += (" " + CLASSES.at(topClasses[idx].item().toInt()));
	}
	classification_.set__data(ans);
	classifications_[topClasses[0].item().toInt()]++;

	// Does not work on my Arch Linux. Uncomment to see visualization of input
//	cv::resize(img, img_show, cv::Size(1280, 960));
//	cv::putText(img_show, ans, cv::Point2i(10, 40), cv::FONT_HERSHEY_TRIPLEX, 1.4, cv::Scalar(0, 255 ,0));
//	cv::imshow("Garbage Classification Image", img_show);
//	cv::waitKey(10);

	// Print running total of classifications
	ans.clear();
	unsigned total = 0;
	for (unsigned x = 0; x < 6; x++) {
		ans += (CLASSES.at(x) + ":" + std::to_string(classifications_[x]) + " ");
		total += classifications_[x];
	}
	ans += "total:" + std::to_string(total);

	RCLCPP_INFO(this->get_logger(), ans);
	classification_pub_->publish(classification_);
}

} // of namespace Garbage_classificationCompdef

/************************************************************
 End of Garbage_classification_impl class body
 ************************************************************/

