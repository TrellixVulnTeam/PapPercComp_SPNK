// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Rgbd_surface_reconstructionCompdef_Rgbd_surface_reconstruction_impl_BODY

/************************************************************
 Rgbd_surface_reconstruction_impl class body
 ************************************************************/

// include associated header file
#include "Rgbd_surface_reconstructionCompdef/Rgbd_surface_reconstruction_impl.h"

// Derived includes directives
#include "rclcpp/rclcpp.hpp"

// abs()
#include <stdlib.h>

//#include <tf2/transform_datatypes.h>
#include <tf2/LinearMath/Matrix3x3.h>
#include <tf2/LinearMath/Quaternion.h>

#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"


namespace Rgbd_surface_reconstructionCompdef {

// static attributes (if any)
int  encoding2mat_type(const std::string & encoding);
void image_message_to_cv(cv::Mat &frame, sensor_msgs::msg::Image::SharedPtr msg);
void pose_to_transform(
    geometry_msgs::msg::PoseStamped::SharedPtr pose, float* matrix_array);

/**
 * 
 * @param options 
 */
Rgbd_surface_reconstruction_impl::Rgbd_surface_reconstruction_impl(
		rclcpp::NodeOptions /*in*/options) :
		Rgbd_surface_reconstruction(options) {
	
	_tsdf_fusion.init();
	_tsdf_fusion.set_intrinsics(468.60, 468.61, 318.27, 243.99);
}

Rgbd_surface_reconstruction_impl::~Rgbd_surface_reconstruction_impl()
{
}

/**
 * 
 * @param image 
 */
void Rgbd_surface_reconstruction_impl::depth_image_handler(
		const sensor_msgs::msg::Image::SharedPtr /*in*/image) {
	_depth_image = image;

	if(!_depth_image_initialized)
		_depth_image_initialized = true;

	//process_frames();
}

void Rgbd_surface_reconstruction_impl::pose_handler(
		const geometry_msgs::msg::PoseStamped::SharedPtr /*in*/pose) {
	_pose = pose;

	if(!_pose_initialized)
		_pose_initialized = true;
	
	process_frames();

}

/**
 * 
 * @param image 
 */
void Rgbd_surface_reconstruction_impl::color_image_handler(
		const sensor_msgs::msg::Image::SharedPtr /*in*/image) {
	_color_image = image;

	if(!_color_image_initialized)
		_color_image_initialized = true;

}

void Rgbd_surface_reconstruction_impl::process_frames(){
	if(!_depth_image_initialized || !_pose_initialized)
		return;
	
	double depth_image_timestamp = _depth_image->header.stamp.sec + _depth_image->header.stamp.nanosec/1000000000.0;
	double pose_timestamp = _pose->header.stamp.sec + _pose->header.stamp.nanosec/1000000000.0;
	
	//If two messages are closer than 16ms we assume they belong together.
	/*if(!(abs(depth_image_timestamp - pose_timestamp)  <= 0.016)) {
		std::cout << "Out of range " << depth_image_timestamp << " "<< pose_timestamp << " "<< abs(depth_image_timestamp - pose_timestamp) << std::endl;
		return;
	}*/

	cv::Mat depth_map, color_map;

	image_message_to_cv(depth_map, _depth_image);
	image_message_to_cv(color_map, _color_image);

	cv::imshow("depth_map", depth_map);
	//cv::imshow("color_map", color_map);
	cv::waitKey(1);

	float matrix_array[16];
	pose_to_transform(_pose, matrix_array);
	_tsdf_fusion.integrate_frame(depth_map, matrix_array);


	// Retrieve camera poses
	//auto poses = _kinect_pipeline_ptr->get_poses();

	// Export surface mesh
	//auto mesh = _kinect_pipeline_ptr->extract_mesh();
	//kinectfusion::export_ply("~/temp/mesh.ply", mesh);


}

// from ROS2 image_tools demo [https://github.com/ros2/demos/blob/eloquent/image_tools/src/showimage.cpp]
int encoding2mat_type(const std::string & encoding) {
	if (encoding == "mono8") {
	return CV_8UC1;
	} else if (encoding == "bgr8") {
	return CV_8UC3;
	} else if (encoding == "mono16") {
	return CV_16SC1;
	} else if (encoding == "rgba8") {
	return CV_8UC4;
	} else if (encoding == "bgra8") {
	return CV_8UC4;
	} else if (encoding == "32FC1") {
	return CV_32FC1;
	} else if (encoding == "rgb8") {
	return CV_8UC3;
	} else {
	throw std::runtime_error("Unsupported encoding type");
	}
}

void image_message_to_cv(cv::Mat &frame, sensor_msgs::msg::Image::SharedPtr msg) {
	cv::Mat tmp_frame(
        msg->height, msg->width, encoding2mat_type(msg->encoding),
        const_cast<unsigned char *>(msg->data.data()), msg->step);
	
	frame = tmp_frame;
}

void pose_to_transform(
    geometry_msgs::msg::PoseStamped::SharedPtr pose, float* matrix_array){

    tf2::Quaternion q(pose->pose.orientation.x, pose->pose.orientation.y,
                     pose->pose.orientation.z, pose->pose.orientation.w);

    tf2::Matrix3x3 m(q);

    std::vector<float> matrix;

    for(int i = 0; i < 3; i++)
        matrix.push_back(m[0][i]);

    matrix.push_back(pose->pose.position.x);

    for(int i = 0; i < 3; i++)
        matrix.push_back(m[1][i]);

    matrix.push_back(pose->pose.position.y);

    for(int i = 0; i < 3; i++)
        matrix.push_back(m[2][i]);

    matrix.push_back(pose->pose.position.z);

    for(int i = 0; i < 3; i++)
        matrix.push_back(0.0);

    matrix.push_back(1.0);

	std::copy(matrix.begin(), matrix.end(), matrix_array); 
}

} // of namespace Rgbd_surface_reconstructionCompdef

/************************************************************
 End of Rgbd_surface_reconstruction_impl class body
 ************************************************************/
