// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Rgbd_surface_reconstructionCompdef_Rgbd_surface_reconstruction_impl_BODY

/************************************************************
 Rgbd_surface_reconstruction_impl class body
 ************************************************************/

// include associated header file
#include "Rgbd_surface_reconstructionCompdef/Rgbd_surface_reconstruction_impl.h"

// Derived includes directives
#include "rclcpp/rclcpp.hpp"

// abs()
#include <stdlib.h>

#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"


namespace Rgbd_surface_reconstructionCompdef {

// static attributes (if any)
int  encoding2mat_type(const std::string & encoding);
void image_message_to_cv(cv::Mat &frame, sensor_msgs::msg::Image::SharedPtr msg);

/**
 * 
 * @param options 
 */
Rgbd_surface_reconstruction_impl::Rgbd_surface_reconstruction_impl(
		rclcpp::NodeOptions /*in*/options) :
		Rgbd_surface_reconstruction(options) {

			kinectfusion::GlobalConfiguration configuration;
			configuration.voxel_scale = 2.f;
			configuration.init_depth = 700.f;
			configuration.distance_threshold = 10.f;
			configuration.angle_threshold = 20.f;

			_kinect_pipeline_ptr = new kinectfusion::Pipeline(_camera.get_parameters(), configuration);
}

Rgbd_surface_reconstruction_impl::~Rgbd_surface_reconstruction_impl()
{
	delete _kinect_pipeline_ptr;
}

/**
 * 
 * @param image 
 */
void Rgbd_surface_reconstruction_impl::depth_image_handler(
		const sensor_msgs::msg::Image::SharedPtr /*in*/image) {
	_depth_image = image;

	if(!_depth_image_initialized)
		_depth_image_initialized = true;

	process_frames();
}

void Rgbd_surface_reconstruction_impl::pose_handler(
		const geometry_msgs::msg::PoseStamped::SharedPtr /*in*/pose) {
	_pose = pose;

	if(!_pose_initialized)
		_pose_initialized = true;

}

/**
 * 
 * @param image 
 */
void Rgbd_surface_reconstruction_impl::color_image_handler(
		const sensor_msgs::msg::Image::SharedPtr /*in*/image) {
	_color_image = image;

	if(!_color_image_initialized)
		_color_image_initialized = true;

}

void Rgbd_surface_reconstruction_impl::process_frames(){
	if(!_depth_image_initialized || !_color_image_initialized)
		return;
	
	double depth_image_timestamp = _depth_image->header.stamp.sec + _depth_image->header.stamp.nanosec/1000000000.0;
	double color_image_timestamp = _color_image->header.stamp.sec + _color_image->header.stamp.nanosec/1000000000.0;
	
	//If two messages are closer than 16ms we assume they belong together.
	if(!(abs(depth_image_timestamp - color_image_timestamp)  <= 0.016)) 
		return;

	cv::Mat depth_map, color_map;

	image_message_to_cv(depth_map, _depth_image);
	image_message_to_cv(color_map, _color_image);

	cv::imshow("depth_map", depth_map);
	cv::imshow("color_map", color_map);
	cv::waitKey(1);

	bool success = _kinect_pipeline_ptr->process_frame(depth_map, color_map);
    if (!success)
        std::cout << "Frame could not be processed" << std::endl;
	else	
        std::cout << "Frame could be processed" << std::endl;


	cv::imshow("Pipeline Output", _kinect_pipeline_ptr->get_last_model_frame());
	cv::waitKey(1);

	// Retrieve camera poses
	//auto poses = _kinect_pipeline_ptr->get_poses();

	// Export surface mesh
	//auto mesh = _kinect_pipeline_ptr->extract_mesh();
	//kinectfusion::export_ply("~/temp/mesh.ply", mesh);


}

// from ROS2 image_tools demo [https://github.com/ros2/demos/blob/eloquent/image_tools/src/showimage.cpp]
int encoding2mat_type(const std::string & encoding) {
	if (encoding == "mono8") {
	return CV_8UC1;
	} else if (encoding == "bgr8") {
	return CV_8UC3;
	} else if (encoding == "mono16") {
	return CV_16SC1;
	} else if (encoding == "rgba8") {
	return CV_8UC4;
	} else if (encoding == "bgra8") {
	return CV_8UC4;
	} else if (encoding == "32FC1") {
	return CV_32FC1;
	} else if (encoding == "rgb8") {
	return CV_8UC3;
	} else {
	throw std::runtime_error("Unsupported encoding type");
	}
}

void image_message_to_cv(cv::Mat &frame, sensor_msgs::msg::Image::SharedPtr msg) {
	cv::Mat tmp_frame(
        msg->height, msg->width, encoding2mat_type(msg->encoding),
        const_cast<unsigned char *>(msg->data.data()), msg->step);
	
	frame = tmp_frame;
}

} // of namespace Rgbd_surface_reconstructionCompdef

/************************************************************
 End of Rgbd_surface_reconstruction_impl class body
 ************************************************************/
